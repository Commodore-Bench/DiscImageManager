#!/usr/bin/perl -w

# module.pl
# Greg Cook, 16 December 2023

# Adds a relocation table to a modularisable RFS ROM created by
# Disc Image Manager.  Produces a Sideways ROM module in the
# format developed by J.G.Harston:
#   https://mdfs.net/Software/BBC/Modules/

# Usage: perl module.pl [-D] [-t] [-v] FILE...
#   -D      enable debugging output
#   -v      enable verbose messages
#   FILE... modularisable RFS ROM(s) generated by Disc Image Manager
#           (will be modified in place)
# NB: Make a backup of the ROM image(s) before processing.

use strict;
use Getopt::Std;
use Fcntl;
use POSIX qw(SEEK_SET SEEK_CUR SEEK_END);

my $CODE_SIZE = 0x4e;
my $SIG = "DiscImageManager";

my %o;
getopts("Dv", \%o);

die "$0: usage: perl $0 [-D] [-v] FILE...\n" unless scalar(@ARGV);

my $base = 0x8000;

FILE: for(; scalar(@ARGV); shift(@ARGV)) {
  my ($reloc,$c,$addr,$i,$next,$sr,$top,$buf,$reloc0,$stop,$low);
  my ($block,$crc);
  sysopen(ROM, $ARGV[0], Fcntl::O_RDWR)
    or die "$0: ".$ARGV[0].": cannot open for update: $!\n";
  seek(ROM,7,POSIX::SEEK_SET)
    or die "$0: ".$ARGV[0].": seek error: $!\n";
  read(ROM,$c,1)==1
    or die "$0: ".$ARGV[0].": cannot read: $!\n";
  $addr=unpack("C",$c);
  seek(ROM,$addr,POSIX::SEEK_SET)
    or die "$0: ".$ARGV[0].": seek error: $!\n";
  read(ROM,$c,4)==4
    or die "$0: ".$ARGV[0].": cannot read: $!\n";
  unless($c eq "\x00(C)") {
    warn "$0: ".$ARGV[0].": not a valid ROM, skipping\n";
    next;
  }
  seek(ROM,4,POSIX::SEEK_SET)
    or die "$0: ".$ARGV[0].": seek error: $!\n";
  read(ROM,$c,2)==2
    or die "$0: ".$ARGV[0].": cannot read: $!\n";
  $addr=unpack("v",$c)-$base;
  if($addr<0x0c) {
    warn "$0: ".$ARGV[0].": invalid jump address, skipping\n";
    next;
  }
  seek(ROM,0,POSIX::SEEK_END)
    or die "$0: ".$ARGV[0].": seek error: $!\n";
  $reloc=tell(ROM);
  if($reloc<$addr+$CODE_SIZE+0x02+length($SIG)+0x01) {
    warn "$0: ".$ARGV[0].": short ROM, skipping\n";
    next;
  }
  seek(ROM,$addr+$CODE_SIZE+0x02,POSIX::SEEK_SET)
    or die "$0: ".$ARGV[0].": seek error: $!\n";
  read(ROM,$c,length($SIG))==length($SIG)
    or die "$0: ".$ARGV[0].": cannot read: $!\n";
  if($c ne $SIG) {
    warn "$0: ".$ARGV[0].": not a relocatable ROM, skipping\n";
    next;
  }
  # parse the RFS stream to find the end marker
  read(ROM,$c,1)==1
    or die "$0: ".$ARGV[0].": cannot read: $!\n";
  while($c ne "\x2b") {
    if($c ne "\x2a" && $c ne "\x23") {
      warn "$0: ".$ARGV[0].": invalid RFS block marker, skipping\n";
      next FILE;
    } else {
      if($c eq "\x23") {
        $block = 0x100;
      } else {
        $i=0; $crc=0x0000;
        do {
          read(ROM,$c,1)==1
            or die "$0: ".$ARGV[0].": cannot read: $!\n";
          $crc = &crc16($c,$crc);
        } while(++$i<11 && $c ne "\x00");
        if($c ne "\x00") {
          warn "$0: ".$ARGV[0].": invalid RFS file name, skipping\n";
          next FILE;
        }
        read(ROM,$c,19)==19
          or die "$0: ".$ARGV[0].": cannot read: $!\n";
        if(&crc16($c,$crc) != 0x0000) {
          warn "$0: ".$ARGV[0].": invalid RFS header CRC, skipping\n";
          next FILE;
        }
        $block = unpack("v",substr($c,10,2));
      }
      if($block > 0) {
        read(ROM,$c,$block+2)==$block+2
          or die "$0: ".$ARGV[0].": cannot read: $!\n";
        if(&crc16($c) != 0x0000) {
          warn "$0: ".$ARGV[0].": invalid RFS data CRC, skipping\n";
          next FILE;
        }
      }
    }
    read(ROM,$c,1)==1
      or die "$0: ".$ARGV[0].": cannot read: $!\n";
  }
  $reloc=tell(ROM);
  $buf=pack("v",$reloc+$base);
  truncate(ROM,$reloc)
    or die "$0: ".$ARGV[0].": cannot truncate: $!\n";
  seek(ROM,0,POSIX::SEEK_SET)
    or die "$0: ".$ARGV[0].": seek error: $!\n";
  print ROM "\x00",$buf
    or die "$0: ".$ARGV[0].": cannot write: $!\n";
  seek(ROM,3,POSIX::SEEK_SET) #flush channel between read/write or write/read
    or die "$0: ".$ARGV[0].": seek error: $!\n";
  $next=2; $stop=$reloc0=$reloc; $low=0x100;
  $sr=0; $top=0;
  for($i=1; $i<$reloc0-2; ++$i) {
    read(ROM,$c,1)==1
      or die "$0: ".$ARGV[0].": cannot read: $!\n";
    $buf.=$c; $buf = substr($buf,-3);
    # $i = offset of first character in $buf
    # $c was read from ($i+2), PTR = $i+3
    $c = unpack("C",substr($buf,0,1));
    printf STDERR "%s: %4x %4x %4x %4x %4x %4x %s %02x %1x\n",
      $0,$i,$next,$addr,$stop,$reloc0,$reloc,unpack("H*",$buf),$sr,$top
      if $o{"D"};
    if($c >= 0x80 && $c < 0xc0) {
      $sr |= ($i == $next) << $top++;
      if($top == 8) {
        seek(ROM,$reloc++,POSIX::SEEK_SET)
          or die "$0: ".$ARGV[0].": seek error: $!\n";
        print ROM pack("C",$sr)
          or die "$0: ".$ARGV[0].": cannot write: $!\n";
        seek(ROM,$i+3,POSIX::SEEK_SET)
          or die "$0: ".$ARGV[0].": seek error: $!\n";
        $sr = $top = 0;
      }
      if($i >= $next) {
        if($i >= $stop) {
          $next = $reloc0;
        } elsif($i >= 5) {
          $next = $stop;
        } elsif($i >= 2) {
          $next = 5;
        }
      }
    }
    if($i >= $addr && $i < $stop) {
      # Checked against false positives.  Instead of this clause,
      # could inject the offsets of the known relocatable references
      # in the chain above.
      if(($c == 0x20 || $c == 0x6d || $c == 0xac)
        && substr($buf,2,1) eq "\x80") {
        $next = $i+2;
      } elsif($c == 0xa9 && substr($buf,2,1) eq "\x85") {
        if($low < 0x100) {
          $next = $stop
            = (unpack("C",substr($buf,1,1)) << 8 | $low) - $base - 0x11;
        } else {
          $low = unpack("C",substr($buf,1,1));
        }
      }
    }
  }
  # $buf == ($reloc0-3..1), PTR=$reloc0
  for($i=1; $i<3; ++$i) {
    $c = unpack("C",substr($buf,$i,1));
    if($c >= 0x80 && $c < 0xc0) {
      $sr |= ($i == 2) << $top++;
      if($top == 8) {
        seek(ROM,$reloc++,POSIX::SEEK_SET)
          or die "$0: ".$ARGV[0].": seek error: $!\n";
        print ROM pack("C",$sr)
          or die "$0: ".$ARGV[0].": cannot write: $!\n";
        $sr = $top = 0;
      }
    }
  }
  if($top > 0) {
    seek(ROM,$reloc,POSIX::SEEK_SET)
      or die "$0: ".$ARGV[0].": seek error: $!\n";
    print ROM pack("C",$sr)
      or die "$0: ".$ARGV[0].": cannot write: $!\n";
  }
  printf STDERR "%s: %s: relocation table at 0x%04x + 0x%02x bytes "
    ."+ %d bits = %d bits\n", $0, $ARGV[0], $reloc0, $reloc-$reloc0,
    $top, (($reloc-$reloc0) << 3) + $top if $o{"v"};
  close(ROM);
  shift(@ARGV);
}
close(ROM);
exit(0);

sub crc16 ($;$) {
  # return Acorn-style 16-bit cyclic redundancy check
  # See BBC User Guide p.365 (B+ User Guide p.369)
  # Argument: binary string
  # Returns: CRC for argument (in decimal)

  my ($input,$crc) = @_;
  my ($iter,$char);
  $crc = 0x0000 unless defined($crc);

  for($iter=0; $iter<length($input); ++$iter) {
    $char = unpack('C',substr($input,$iter,1));
    $crc = ($crc & 0xFF) << 8 | ($crc & 0xFF00) >> 8 ^ $char;
    $crc ^= (($crc & 0xF0) >> 4) * 0x0201;
    $crc ^= ($crc & 0x0F) * 0x1020;
  }
  return($crc);
}
